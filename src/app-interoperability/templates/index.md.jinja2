# Application Package Definition

This section addresses how an application is packaged by the “Application Developer” who has implemented the application and aims to provide it to Margo-conformant systems. An application aggregates one or more [OCI Containers](https://github.com/opencontainers). The **application package** is made available in an [application registry](./workload-orch-to-app-reg-interaction.md).  

The application package comprises:

- The **application description** file `margo.yaml`, which contains information about the application's marketing details (e.g., description, icon, release notes, license file, etc.), resource requirements, required input parameters, and application's supported deployment configurations (e.g,  Helm charts, docker-compose package).
- The **application resources** which can be used to display additional information about the application in an application catalog or marketplace based on the application's defined metadata (e.g., description, icon, release notes, license file, etc.).

    > **Note**  
    > Application Marketplaces are out of scope for Margo. The exact requirements of the Marketing Material shall be defined by the Application Marketplace beyond outlined mandatory content.

The application package's deployment configuration SHALL be defined as Helm Charts AND/OR a Docker Compose packages.

- To target devices running Kubernetes applications must be packaged as helm charts using [Helm V3](https://helm.sh/).
- To target devices deploying applications using Docker Compose files you must create a tarball file containing the application's docker-compose.yml file and any additional artifacts referenced by the docker compose file (e.g., configuration files, environment variable files, etc.). It is highly recommend to digitally sign this package. When digitally signing the package PGP MUST be used.

> **Investigation Needed**: We plan to do a security review of this package definition later.
> During this review we will revisit the way the docker compose tarball file should be signed.
> We will also discuss how we should handle secure container registries that require a username and password.
>
> **Investigation Needed**: We need to determine what impact, if any, using 3rd party helm charts has on being Margo compliant.
>
> **Investigation Needed**: Missing in the current specification are ways to define the compatibility information (resources required to run, application dependencies) as well as required infrastructure  services  such as storage, message queues/bus, reverse proxy, or authentication/authorization/accounting.

If either one cannot be implemented it MAY be omitted but Margo RECOMMENDS defining components for both Helm Chart **AND** Docker Compose packages to strengthen interoperability and applicability.

> **Note**
> A device running the application will only install the application using either Docker Compose files or Helm Charts but not both.

## Application Package Structure

The application package has the following folder structure:

```yaml
/                            # REQUIRED top-level directory 
└── margo.yaml               # REQUIRED application description file in YAML Format 
└── resources                # OPTIONAL folder with application catalog resources e.g., icon, license file, release notes 
```


## Application Description

The `margo.yaml` file is the application description. The purpose of this file is to present the application on an application catalog or marketplace from where an end user selects the application to hand it over to the Workload Orchestration Software, which configures it and makes it available for installation on the edge device (see Section [Workload Management Interface](../orchestration/workload/workload-management-interface-breakdown.md)).

### Application Description Example

A simple hello-world example of an `margo.yaml` file is shown below:

```yaml
{% include 'ApplicationDescription-001.yaml' %}
```

An example of a `margo.yaml` file using multiple helm charts and a docker-compose file package is shown below.

```yaml
{% include 'ApplicationDescription-002.yaml' %}
```

### Top-level Attributes

{% macro abort(error) %}
    {{ None['[ERROR] ' ~ error][0] }}
{% endmacro %}

{%- macro format_range(slot) -%}
    {%- if slot.multivalued and slot.inlined -%}
        {%- if slot.inlined_as_list -%}
            []{{ slot.range }}
        {%- else -%}
            {%- if slot.name == "properties" -%}
                map[string][string]
            {%- else -%}
                map[string][{{ slot.range }}]
            {%- endif -%}
        {%- endif -%}
    {%- else -%}
        {{ slot.range }}
    {%- endif -%}
{%- endmacro -%}

| Attribute | Type | Required? | Description |
| --- | --- | --- | --- |
{% for slot in schemaview.class_slots("ApplicationDescription")|sort(attribute='rank') -%}
| {{ slot }} | {{ schemaview.get_slot(slot).range }} | {% if schemaview.get_slot(slot).required == True %} Y {% else %} N {% endif %} | {{ schemaview.get_slot(slot).description }}|
{% endfor -%}

{% for c in gen.all_class_objects()|sort(attribute='rank') %}
{%- if c.name != "ApplicationDescription" and not c.name.startswith("Helm") and not c.name.startswith("DockerCompose") and not c.name == "Property" %}
#### {{ c.name }} Attributes

| Attribute | Type | Required? | Description |
| --- | --- | --- | --- |
{% for slot in gen.get_direct_slots(c)|sort(attribute='rank') -%}
{%- if slot.name != "value" -%}
| {{ slot.name }} | {{ format_range(slot) }} | {% if slot.required == True %} Y {% else %} N {% endif %} | {{ slot.description }}|
{%- else -%}
| {{ slot.name }} | <*see description*> | {% if slot.required == True %} Y {% else %} N {% endif %} | {{ slot.description }}|
{%- endif %}
{% endfor %}
{%- endif %}
{%- endfor %}
